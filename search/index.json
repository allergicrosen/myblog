[{"content":"具体过程：\n结构优化 静态计算 计算partial charge 执行op（给权限，chmod 777 op） partial charge input 重叠积分计算可执行文件 附录 参考文章 ","date":"2025-02-16T14:45:25+08:00","permalink":"https://allergicrosen.fun/p/wave_function_overlap_integral_cp2k/","title":"Wave_function_overlap_integral_CP2K"},{"content":"说明：本文只是操作教程，具体原理请查看手册 推荐环境：VSCODE+LaTeX Workshop（扩展）\n参考文献插入与引用 模板默认指定〈bib=bibtex〉，模板将调用 gbt7714 宏包 确保tex同目录下存在bib文件，且文内正确调用了 \\bibliography{references.bib} bibtex规则见下面 文中需要正确引用 bibtex规则： references.bib 文件是 BibTeX 或 biblatex 的参考文献数据库文件，用于存储参考文献的元数据（如作者、标题、年份等）。每条参考文献条目都遵循一定的规则和格式。以下是详细的规则和说明：\n基本结构 每个参考文献条目由以下部分组成： 条目类型 ：指定文献的类型，例如 @article（期刊文章）、@book（书籍）、@online（在线资源）等。 唯一标识符（Key） ：为每条参考文献分配一个唯一的标识符，用于在正文中引用（如 \\cite{key}）。 字段列表 ：包含描述文献的键值对，键是字段名称（如 author、title），值是对应的元数据。 示例条目\n@article{einstein1905, author = {Albert Einstein}, title = {On the Electrodynamics of Moving Bodies}, journal = {Annalen der Physik}, year = {1905}, volume = {322}, pages = {891--921} } 条目类型 不同的文献类型对应不同的条目类型。以下是一些常见的条目类型及其用途： @article 学术期刊文章 @book 书籍 @inproceedings 会议论文集中的文章 @incollection 书籍中的一章或一节 @phdthesis 博士学位论文 @mastersthesis 硕士学位论文 @techreport 技术报告 @misc 其他未分类的文献（如网页、博客等） @online 在线资源（仅适用于 biblatex（BibTeX 不支持此类型） 3. 字段规则 每个条目类型的字段可能有所不同，但以下是一些通用的字段及其含义：\nauthor 作者姓名，多个作者用 and 分隔，例如： John Doe and Jane Smith title 文献标题 journal 期刊名称（适用于 @article 类型） year 出版年份 volume 期刊卷号（适用于 @article 类型） number 期刊期号（适用于 @article 类型） pages 页码范围，例如： 123\u0026ndash;145 publisher 出版商名称（适用于 @book 和 @techreport 类型） address 出版地点（适用于 @book 和 @techreport 类型） url 在线资源的 URL 地址（适用于 @online 和 @misc 类型） doi 数字对象标识符（DOI） edition 版本号（适用于 @book 类型） translator 翻译者（适用于翻译作品） note 备注信息（可选） 4. 示例条目 以下是一些常见文献类型的示例：\n(1) 期刊文章 (@article)\n@article{einstein1905, author = {Albert Einstein}, title = {On the Electrodynamics of Moving Bodies}, journal = {Annalen der Physik}, year = {1905}, volume = {322}, number = {10}, pages = {891--921}, doi = {10.1002/andp.19053221004} } (2) 书籍 (@book)\n@book{knuth1984, author = {Donald E. Knuth}, title = {The \\TeX book}, publisher = {Addison-Wesley}, year = {1984}, address = {Reading, Massachusetts}, edition = {1} } (3) 会议论文 (@inproceedings)\n@inproceedings{smith2020, author = {John Smith and Jane Doe}, title = {A Study on Machine Learning Techniques}, booktitle = {Proceedings of the International Conference on AI}, year = {2020}, pages = {123--130}, address = {New York, USA}, publisher = {ACM} } (4) 在线资源 (@online)\nauthor = {Tobias Oetiker and Hubert Partl and Irene Hyna and Elisabeth Schlegl}, translator = {\\CTeX\\ 开发小组}, title = {一份 (不太) 简短的 \\LaTeXe\\ 介绍}, edition = {6.03}, year = {2021}, url = {https://ctan.org/pkg/lshort-cn}, urldate = {2023-10-01} % 访问日期 } 特殊规则 (1) 多作者处理 多个作者之间用 and 分隔，而不是逗号或其他符号。例如： author = {John Doe and Jane Smith and Alice Johnson} (2) 特殊字符 如果字段中包含特殊字符（如 LaTeX 命令），需要使用大括号 {} 包裹以保护它们。例如：\ntitle = {The \\LaTeX\\ Book: A Guide to Typesetting with {\\TeX}} (3) 非英文字符 对于非英文字符（如中文），建议使用 UTF-8 编码保存 .bib 文件，并确保编译器支持 UTF-8。例如：\nauthor = {廖金波}, title = {有机无机杂化钙钛矿光电性质研究及调控}, (4) 日期字段 biblatex 支持更灵活的日期字段（如 date 和 urldate），可以使用 ISO 格式（YYYY-MM-DD）。例如：\nurldate = {2023-10-01} 注意事项 唯一标识符（Key） ：每个条目的 key 必须唯一，通常使用作者名和年份的组合（如 einstein1905）。 字段完整性 ：尽量填写所有必要的字段，以确保生成的参考文献完整且规范。 避免拼写错误 ：检查字段名称和内容是否正确，避免因拼写错误导致编译失败或引用错误。 清理辅助文件 ：如果修改了 .bib 文件后出现错误，可以删除 .aux、.bbl 等辅助文件后重新编译。 附录 参考文章 ","date":"2025-02-14T15:37:24+08:00","permalink":"https://allergicrosen.fun/p/latex_thesis_writing/","title":"Latex_thesis_writing"},{"content":"记录些有用的命令 rsync rsync -av --progress source/ destination/\ncp命令复制太慢也不显示进度，此命令较快且可以知道进度\n参数说明： -a：归档模式，保留文件属性（如权限、时间戳等），并递归复制目录。\n-v：显示详细输出，便于跟踪进度。\n--progress：显示复制进度。\n为什么 rsync 更快？\n增量传输：rsync 只复制源和目标之间不同的部分，而不是整个文件。\n压缩传输：可以通过 -z 参数启用压缩，减少传输数据量。\n高效算法：rsync 使用高效的算法来比较文件差异，减少不必要的复制。\n加速复制的额外选项\n**⚪ 启用压缩：**如果复制大量小文件或网络传输，可以启用压缩：\nrsync -avz --progress source/ destination/\n**⚪ 并行复制：**对于大量小文件，可以使用 \u0026ndash;progress 和 \u0026ndash;partial 来加速：\nrsync -av --progress --partial source/ destination/\n**⚪ 多线程复制：**如果需要更快速度，可以使用 rsync 的多线程功能（需要较新版本的 rsync）：\nrsync -av --progress --partial --inplace --rsh=\u0026quot;ssh -T -c aes128-ctr -o Compression=no -x\u0026quot; source/ destination/\n**注意事项 ** 源路径的斜杠：\n如果源路径以斜杠结尾（如 source/），rsync 会复制目录内容到目标路径。\n如果源路径不以斜杠结尾（如 source），rsync 会复制整个目录到目标路径。\n目标路径：\n如果目标路径不存在，rsync 会自动创建。\n网络传输：\n如果源和目标位于不同机器，可以通过 SSH 使用 rsync：\nrsync -avz --progress -e ssh user@remote:/source/ /destination/\nawk 处理大型数据该命令非常高效，且无需其它环境\nawk '{sum += ($2 \u0026lt; 0 ? -$2 : $2); count++} END {print sum/count}' data.txt\n例如计算data.txt第二列数据绝对值和的平均值，秒出结果！！！\nawk 是一种强大的文本处理工具，专门用于逐行处理和分析结构化文本数据（如 CSV、日志文件等）。它的名字来源于其三位创始人 Alfred Aho、Peter Weinberger 和 Brian Kernighan 的姓氏首字母。\nawk 的基本工作原理是：\n逐行读取输入文件。\n根据指定的规则（模式）匹配行。\n对匹配的行执行相应的操作（动作）。\nawk 'pattern { action }' input_file\n**pattern：**匹配行的条件（可选）。如果省略，则对所有行执行 action。\n**action：**对匹配行执行的操作（可选）。如果省略，则默认打印匹配的行。\n**input_file：**输入文件。如果省略，则从标准输入读取数据。\n常用变量 $0：整行内容。\n$1, $2, \u0026hellip;, $N：第 1、2、\u0026hellip;、N 列的内容（默认以空格或制表符分隔）。\nNF：当前行的列数。\nNR：当前行的行号。\nFS：输入字段分隔符（默认是空格或制表符）。\nOFS：输出字段分隔符（默认是空格）。\n示例文件 假设有一个文件 data.txt，内容如下：\n1 10.5 A 2 -3.2 B 3 7.8 C 4 -1.1 D 打印整行\nawk \u0026#39;{print $0}\u0026#39; data.txt 打印指定列\n打印第二列：\nawk \u0026#39;{print $2}\u0026#39; data.txt 条件过滤\n打印第二列大于 0 的行：\nawk \u0026#39;$2 \u0026gt; 0 {print $0}\u0026#39; data.txt 计算列的平均值\n计算第二列的平均值：\nawk \u0026#39;{sum += $2; count++} END {print sum/count}\u0026#39; data.txt 修改字段分隔符\n如果文件是以逗号分隔的 CSV 文件，可以修改 FS：\nawk -F, \u0026#39;{print $2}\u0026#39; data.csv 取绝对值并计算平均值\n对第二列取绝对值并计算平均值：\nawk \u0026#39;{sum += ($2 \u0026lt; 0 ? -$2 : $2); count++} END {print sum/count}\u0026#39; data.txt 添加行号\n打印每行内容并添加行号：\nawk \u0026#39;{print NR, $0}\u0026#39; data.txt 多条件匹配\n打印第二列大于 0 且第三列是 \u0026ldquo;A\u0026rdquo; 或 \u0026ldquo;B\u0026rdquo; 的行：\nawk \u0026#39;$2 \u0026gt; 0 \u0026amp;\u0026amp; ($3 == \u0026#34;A\u0026#34; || $3 == \u0026#34;B\u0026#34;) {print $0}\u0026#39; data.txt 附录 参考文章 ","date":"2025-01-16T01:34:15+08:00","permalink":"https://allergicrosen.fun/p/shell-command/","title":"shell command"},{"content":"介绍VASP对弹性模量，泊松比等力学常数的相关计算。\n弹性常数描述了晶体对外加应变的响应的刚度。在材料的线性变形范围内（应变较小的情况下），体系的应力与应变满足胡克定律(F=-kx )。也就是说，对于足够的小的变形，应力与应变成正比，即应力分量(S)是应变分量(E)的线性函数，材料在各个方向上的弹性模量不同，最好体现这种不同的方式就是将胡克定律推广到矩阵形式。\n三维材料的弹性刚度常数矩阵是6×6的：\n刚度矩阵C是一个对称矩阵Cij =Cji,因此独立矩阵元至多有21个，此外晶系的对称性越高，独立元的数目就越少。有关于各种晶系的弹性矩阵大家可以自行百度搜索。\n计算矩阵 VASP5.2以上版本计算弹性常数很方便，在INCAR中添加IBRION=6,NFREE=4,ISIF=3。计算结束后会产生刚度矩阵，即得到了弹性常数(Cij)\n例如示例INCAR，INCAR建议设置较高精度 ISTART =0 ICHARG = 2 ENCUT=500 EDIFF=1E-8 NSW=1 EDIFFG=-1e-2 ISIF=3 IBRION=6 #计算弹性常数，详见vaspwiki POTIM=0.015 NFREE = 4 其它文件自行准备。\n计算完OUTCAR里面会有刚度矩阵\n提取矩阵并处理 利用vaspkit帮助处理数据\n$ vaspkit \\\\\\/// / _ _ \\ Hey, you must know what you are doing. (| (o)(o) |) Otherwise you might get wrong results. o-----.OOOo--()--oOOO.------------------------------------------o | VASPKIT Standard Edition 1.5.1 (27 Jan. 2024) | | Lead Developer: Vei WANG (wangvei@icloud.com) | | Main Contributors: Gang TANG, Nan XU \u0026amp; Jin-Cheng LIU | | Online Tutorials Available on Website: https://vaspkit.com | o-----.oooO-----------------------------------------------------o ( ) Oooo. VASPKIT Made Simple \\ ( ( ) \\_) ) / (_/ ===================== Structural Utilities ====================== 01) VASP Input-Files Generator 02) Mechanical Properties 03) K-Path for Band-Structure 04) Structure Editor 05) Catalysis-ElectroChem Kit 06) Symmetry Analysis 07) Materials Databases 08) Advanced Structure Models ===================== Electronic Utilities ====================== 11) Density-of-States 21) Band-Structure 23) 3D Band-Structure 25) Hybrid-DFT Band-Structure 26) Fermi-Surface 28) Band-Structure Unfolding 31) Charge-Density Analysis 42) Potential Analysis 44) Piezoelectric Properties 51) Wave-Function Analysis 62) Magnetic Analysis 65) Spin-Texture 68) Transport Properties ======================== Misc Utilities ========================= 71) Optical Properties 72) Molecular-Dynamics Kit 74) User Interface 78) VASP2other Interface 84) ABACUS Interface 91) Semiconductor Kit 92) 2D-Material Kit 95) Phonon Analysis 0) Quit ------------\u0026gt;\u0026gt; 2 =================== Mechanical Options ========================== 200) Elastic-Constants Using Stress-Strain Method 201) Elastic-Constants Using Energy-Strain Method 202) Mechanical Properties from ELASTIC_TENSOR(_2D).in file 203) Elastic-Constants and Mechanical Properties from OUTCAR file 204) Spatial-Dependent Mechanics from ELASTIC_TENSOR(_2D).in file 205) Equation-of-State Fitting 0) Quit 9) Back ------------\u0026gt;\u0026gt; 先输入203，再204，即可得到MECHANICS_3D.dat\n要将该数据绘制成3维图像，可以借助vaspkit中example所带matlab脚本，具体路径在vaspkit/examples/angular_dependent_mechanics/mechanics_3d_plot_matlab.m (VASPKIT ver. \u0026gt;= 1.3.2)\n绘制三维图像 最好在有GUI情况下使用该脚本，尝试过在集群运行无GUI模式无法成功，也尝试过修改代码将图像保存为图片也无法成功，如果有好办法在集群使用欢迎指导。\n具体办法在自己电脑安装Matlab运行脚本，即可成功。\nmatlab命令行输入：mechanics_3d_plot_matlab,输入2，选择绘制杨氏模量。\n得到：\n修改图片并导出\n附录 参考文章 第一性原理||计算不同晶系的弹性常数和弹性模量-模拟计算-科学指南针 第一性原理||计算弹性常数的两种方法-模拟计算-科学指南针 根据弹性常数计算和三维可视化材料力学量 - VASPKIT与量化软件 ","date":"2025-01-08T20:13:35+08:00","permalink":"https://allergicrosen.fun/p/elastic-constants/","title":"弹性常数计算"},{"content":"NAMD计算 记录计算NAMD过程的一些笔记以及注意事项(只记录计算步骤，不涉及背后原理，因为我自己也没搞明白，后续可能会有完善)\n基于凯峰给的NAMD-example\nNAMD_example Mode LastWriteTime Length Name ---- ------------- ------ ---- dar--l 2024/12/10 0:52 NA_couplings dar--l 2024/12/10 0:52 step1 dar--l 2024/12/10 0:52 step2 dar--l 2024/12/10 0:52 step3 dar--l 2024/12/10 0:52 vasp.5.4.4-nac-intel -a---l 2022/11/19 10:39 390 readme NAC计算大致分为三步\n跑MD（包括heating部分和MD部分） 将MD获得的轨迹分割成5000个POSCAR，并对每个POSCAR进行一遍scf（pyxaid一定要单k点跑） 计算寿命，退相干 其中NA_couplings包含计算所需脚本及可执行文件\nStep1，进行vasp的MD计算 heating step1下包含heating和MD\n$ ls heating MD MD过程包含heating和MD两个部分\nheating过程主要使结构在300K下跑1000步（或者500步），并写入WAVECAR,INCAR设置如下：\nSYSTEM = crystal #ISYM = 0 ENCUT = 500 #和先前计算保持一致 LREAL = A ISTART = 0 ISYM = 0 NELM = 200 NPAR = 6 ICHARG = 2 ISMEAR = 0 #feimi 0 gass SIGMA = 0.02 EDIFF = 1E-4 #can be modified NBANDS = 846 # should be modified grep NABNDS OUTCAR PREC = M # Low | Medium | High | Normal | Accurate | Single ##################### MD Ionic Relaxation####################### IBRION=0 #(df:0/(-1 if NSW=0/1))relax method,non:-1,MD:0,CG:2. POTIM=1.0 #(df:0.5)controll the length of the trial step for ionic relax. ISIF=2 #(df:2)Control what to relax. usually:0,all:3. NSW=1000 #(df:0)max. ion relax steps. EDIFFG=-0.01 #(df:EDIFF*10)ionic rel. brake cond. loop force:(-),Ener.(+) NELMIN=6 #(df:2)minimum steps of electronic SC. ALGO = N # FAST is faster than Normal NBLOCK = 4 TEBEG=300 TEEND=300 SMASS=-1 #-1 heating;-3 normal MD.controls the velocities during an ab-initio molecular dynamics ######################Write Flags############################ LWAVE = .T. LCHARG = .FALSE. IVDW = 12 NWRUTE = 1 根据自己需求可以适当修改，使用vasp_gam进行计算\nMD MD过程的POSCAR为计算完heating的CONTCAR，且需要读取heating的WAVECAR ICNAR设置如下：\nSYSTEM = crystal #ISYM = 0 ENCUT = 500 #和先前计算保持一致 LREAL = A ISTART = 1 ISYM = 0 NELM = 120 NPAR = 8 ICHARG = 2 ISMEAR = 0 #feimi 0 gass SIGMA = 0.02 EDIFF = 1E-4 #can be modified #NBANDS = 856 # should be modified grep NABNDS OUTCAR PREC = M # Low | Medium | High | Normal | Accurate | Single ##################### MD Ionic Relaxation####################### IBRION=0 #(df:0/(-1 if NSW=0/1))relax method,non:-1,MD:0,CG:2. POTIM=1.0 #(df:0.5)controll the length of the trial step for ionic relax. ISIF=2 #(df:2)Control what to relax. usually:0,all:3. NSW=5020 #(df:0)max. ion relax steps. EDIFFG=-0.01 #(df:EDIFF*10)ionic rel. brake cond. loop force:(-),Ener.(+) NELMIN=6 #(df:2)minimum steps of electronic SC. ALGO = N # FAST is faster than Normal NBLOCK = 1 TEBEG=300 TEEND=300 SMASS=-3 #-1 heating;-3 normal MD.controls the velocities during an ab-initio molecular dynamics ######################Write Flags############################ LWAVE = .F. LCHARG = .FALSE. IVDW = 12 MD过程NSW离子步设置为5020，使用vasp_gam计算\n计算完成后，需要将MD的轨迹拆分为一个一个POSCAR，可以使用脚本实现。\n轨迹文件在MD目录下生成的XDATCAR，脚本位于NA_couplings文件夹下的gxdatpos\n需要将脚本和轨迹文件放入/step2/pfile/, 然后执行脚本拆分轨迹，获得所需的5020个结构\n需要注意：MD跑完后一定要检查轨迹(导入至VMD中)，看看结构是否正常，否则后续跑NAMD没啥意义\n接下来计算NAC\nStep2，进行NAC计算(单K点!!!) NAC计算非常耗时，成本高，一定要时刻注意是否计算正确，提交任务前一定要检查好参数，尤其是:\nMINB=168 #一定要记得修改！！！ MAXB=177 一定要和EIGENVAL里面保持一致，在SOC或者扩胞后会有变化。\nstep2目录下，有如下文件:\n$ ls combine_complex.py NAC pfile readme real energy name.py read-en-diff-vasp.pl read-nac-vasp.pl res 首先先计算NAC\nNAC目录下，有如下文件：\n$ ls FIRSTCAR readme nac.sh STARTCAR $ cat FIRSTCAR Step 1 adiabatic MD INCAR ISTART=0 ALGO=N #VASP relaxation algorithm NELMDL=-2 LWAVE = .TRUE. LCHARG = .FALSE. LREAL = A NPAR = 8 PREC=M ISMEAR= 0 #set to 0 for partial occupencies of wavefunction have Gaussian smearing SIGMA=0.02 ISYM = 0 #symmetry not considered in calculation NSW=0 EDIFF= 1E-4 EDIFFG=-0.01 IVDW = 12 $ cat STARTCAR Step 1 adiabatic MD INCAR ISTART=1 ALGO=N #VASP relaxation algorithm NELMDL=-2 LWAVE = .TRUE. LCHARG = .FALSE. LREAL = A NPAR = 8 PREC=M ISMEAR= 0 #set to 0 for partial occupencies of wavefunction have Gaussian smearing SIGMA=0.02 ISYM = 0 #symmetry not considered in calculation NSW=0 EDIFF= 1E-4 EDIFFG=-0.01 IVDW = 12 nac.sh脚本需要设置好路径，包括NA_couplings路径 pfile路径（有两处）\nMINB:电子可以激发的最低能量轨道 MAXB:电子可以激发的最高能量轨道 一般MINB设置为VBM占据轨道减去4,MAXB设置为CBM占据轨道加上4(可以在本征值文件EIGENVAL查到) （换了体系或者加了SOC后，一定一定一定记得修改这儿！！！） MINT和MAXT:起始步和结束步。（若要分段算最好第二段往前多算几步，比如1-2505；2500-5005）\n注意自己是用的vasp_gam还是vasp_std\n计算结束后检查energy文件行数和real文件夹中的real文件数是否是对的(多次计算生成的energy内容并不会被覆盖，而是会在末尾继续写入，一定要检查好)\n然后cp energy和real文件到/step2/energy文件和real文件夹\n$ cat nac.sh #!/bin/bash #SBATCH -J ljb-nac # 作业名 #SBATCH -o out.%j # 标准输出文件（%j 为作业 ID） #SBATCH -e err.%j # 标准错误文件 #SBATCH -p mars # 分区名称 #SBATCH -N 1 # 申请 1 个节点 #SBATCH --ntasks-per-node=64 # 每个节点 64 个任务 #SBATCH -t 07-23:57:25 # 运行时间限制 (7天23小时57分25秒) # 加载必要的模块 module purge module load intel/oneapi2023.2_noimpi module load mpi/mpich/4.1.2-gcc-11.4.0-ch4 # 设置 VASP 路径 export PATH=/GLOBALFS/caep_lts_qrhzh_1/liaojinbo/soft/vasp.5.4.4-nac-intel/bin/:$PATH module list # 当前工作目录 cd $SLURM_SUBMIT_DIR echo \u0026#34;ENV Load Done\u0026#34; \u0026gt; Debug.log PATH=$PATH:/GLOBALFS/caep_lts_qrhzh_1/liaojinbo/soft/NA_couplings # puts perl scripts in path export $PATH # 参数设置 MINB=168 #一定要记得修改！！！ MAXB=177 MINT=1 MAXT=5000 total_k=1 TMSTP=1.0 # 打印参数 printf \u0026#34;\\n\\n======= INITIAL PARAMETERS (MINBAND MAXBAND MINTIME MAXTIME) ========\\n\u0026#34; printf \u0026#34;%10d%10d%10d%10d\\n\\n\u0026#34; $MINB $MAXB $MINT $MAXT rm -f billdata OS_STRENGTH in_SPECTRUM test_coupling_os coupling echo \u0026#34;Set up Calcs Done\u0026#34; \u0026gt;\u0026gt; Debug.log # 获取初始 POSCAR 文件 SUFX=$( printf \u0026#34;%04d\u0026#34; \u0026#34;$MINT\u0026#34; ) POSFILE=\u0026#34;p${SUFX}\u0026#34; cp ../pfile/$POSFILE POSCAR #可以更改为相对路径，就不需要每次计算都改这里了 cp FIRSTCAR INCAR # 执行 VASP 初始化计算 printf \u0026#34;Running VASP and getting initial set of good orbitals\\n\u0026#34; yhrun -N 1 -n 64 vasp_std \u0026gt; vasp.out 2\u0026gt; err cat vasp.out \u0026gt;\u0026gt; Debug.log cp WAVECAR WAVECAROLD cp WAVECAR WAVECARNEW cp OUTCAR OUTCAR_total echo \u0026#34;Set Good ORBITALS Done\u0026#34; \u0026gt;\u0026gt; Debug.log # 逐步计算 NAC (( MINT++ )) for i in $(seq $MINT $MAXT); do SUFX=$( printf \u0026#34;%04d\u0026#34; \u0026#34;$i\u0026#34; ) POSFILE=\u0026#34;p${SUFX}\u0026#34; cp ../pfile/$POSFILE POSCAR cp STARTCAR INCAR printf \u0026#34;Running VASP at t = $i fs\\n\u0026#34; yhrun -N 1 -n 64 vasp_std \u0026gt; vasp.out 2\u0026gt; err cat vasp.out \u0026gt;\u0026gt; Debug.log mv WAVECARNEW WAVECAROLD cp WAVECAR WAVECARNEW cat OUTCAR \u0026gt;\u0026gt; OUTCAR_total printf \u0026#34;Getting band energies at t = $i fs\\n\u0026#34; state_energy_extractor_allk.pl $MINB $MAXB cat energy_by_band \u0026gt;\u0026gt; energy # 计算 NAC echo \u0026#34;Calculating the NAC among k points\u0026#34; \u0026gt;\u0026gt; Debug.log yhrun -N 1 -n 16 ovlap_NORM_OS_allk_mpi $MINB $MAXB $TMSTP $total_k $SUFX \u0026gt;\u0026gt; Debug.log rm -f billdata OS_STRENGTH in_SPECTRUM test_coupling_os # 合并 real 文件 for j in $(seq 1 $total_k); do mv \u0026#34;real${SUFX}_${j}_1\u0026#34; \u0026#34;real${SUFX}_${j}\u0026#34; for k in $(seq 2 $total_k); do paste \u0026#34;real${SUFX}_${j}\u0026#34; \u0026#34;real${SUFX}_${j}_${k}\u0026#34; \u0026gt; temp mv temp \u0026#34;real${SUFX}_${j}\u0026#34; rm -f \u0026#34;real${SUFX}_${j}_${k}\u0026#34; done done mv \u0026#34;real${SUFX}_1\u0026#34; \u0026#34;real${SUFX}\u0026#34; for j in $(seq 2 $total_k); do cat \u0026#34;real${SUFX}_${j}\u0026#34; \u0026gt;\u0026gt; \u0026#34;real${SUFX}\u0026#34; rm -f \u0026#34;real${SUFX}_${j}\u0026#34; done done echo \u0026#34;Combine the real files Done\u0026#34; \u0026gt;\u0026gt; Debug.log # 将 real 文件移入目录 (( MINT-- )) REALDIR=\u0026#34;REAL_${MINT}_${MAXT}\u0026#34; mkdir -p $REALDIR mv real* $REALDIR/ echo \u0026#34;Finish\u0026#34; \u0026gt;\u0026gt; Debug.log 可以看到，NAC计算过程还是比较复杂的，在nac.sh脚本帮助下可以大大提高效率。\n计算完成，会在当前目录下创建REALDIR=\u0026quot;REAL_${MINT}_${MAXT}\u0026quot;目录，并将计算得到的real文件移动到此。\n确保step2目录下含: combine_complex.py和name.py，如果没有res文件夹则mkdir res\n使用combine_complex.py脚本在real文件夹中生成哈密顿量的实部和虚部，然后cp real文件夹的实部和虚部到res文件夹\n接着运行name.py,将res文件夹中的文件顺序减2，运行cp.py(记得修改复制循环次数),当然也可以一键运行gennaccopy.sh，省的自己动手。(别忘了这一步，否则namd计算会报错)\n获取带隙波动和NAC：可以将read-en-diff-vasp.pl和read-nac-vasp.pl脚本放到step2最终的res文件，执行这两个脚本得到en-diff.dat和nac.dat。(注意：nac.dat的数值需要取绝对值并算平均值。)\nstep3 获取Population，Dephasing和Spectral_density（基于Pyxaid） step3包含如下文件：\ntotal 329 0 Dec 24 17:02 err.273230 11776 Dec 23 16:41 FFT 11776 Dec 24 17:00 macro 916 Dec 23 16:41 name_new1.py 916 Dec 23 16:41 name_new2.py 916 Dec 23 16:41 name_new3.py 11776 Dec 23 16:41 out 6146 Dec 24 17:02 out.273230 8507 Dec 24 17:07 py-scr3.py 811 Dec 24 17:01 pyxaid-slurm.sh 1596 Dec 24 17:20 readme 12800 Dec 24 17:08 res 12800 Dec 24 16:59 res1 13824 Dec 24 16:59 res2 13824 Dec 24 16:59 res3 旧脚本\nname_new.py作用为复制哈密顿文件并重命名，以5000为例，需要复制3次，得到3个res1，res2，res3。如，设初始res顺序为ABC,则经过脚本处理后res1为ABCBA,res2为ABCBC,res3为ABCAB,将res1、2、3中所有文件cp到新的res文件，会去掉相同的部分，最终得到ABCBABCBA。\n使用name_new.py需要python2.7版本，python3会报错不兼容。\npy-scr3.py脚本（需要修改部分：i, i+namdtime要小于res文件的实部或虚部数量） res1,res2,res3，（为step2的res cp 的，对应与name_new（1，2，3）.py脚本）\n旧脚本\n根据自己需求修改py-scr3.py\n其中py-scr3.py内容为:\n$ cat py-scr3.py from PYXAID import * #from pyxaid_core import * import os print(\u0026#39;import Done\u0026#39;) ############################################################################################# # Input section: Here everything can be defined in programable way, not just in strict format ############################################################################################# print(\u0026#39;Init Params!\u0026#39;) params = {} # Define general control parameters (file names, directories, etc.) # Path to Hamiltonians # These paths must direct to the folder that contains the results of # the step2 calculations (Ham_ and (optinally) Hprime_ files) and give # the prefixes and suffixes of the files to read in rt =os.getcwd() params[\u0026#34;Ham_re_prefix\u0026#34;] = rt+\u0026#34;/res/0_Ham_\u0026#34; params[\u0026#34;Ham_re_suffix\u0026#34;] = \u0026#34;_re\u0026#34; params[\u0026#34;Ham_im_prefix\u0026#34;] = rt+\u0026#34;/res/0_Ham_\u0026#34; params[\u0026#34;Ham_im_suffix\u0026#34;] = \u0026#34;_im\u0026#34; params[\u0026#34;Hprime_x_prefix\u0026#34;] = rt + \u0026#34;/res/0_Hprime_\u0026#34; params[\u0026#34;Hprime_x_suffix\u0026#34;] = \u0026#34;x_re\u0026#34; params[\u0026#34;Hprime_y_prefix\u0026#34;] = rt + \u0026#34;/res/0_Hprime_\u0026#34; params[\u0026#34;Hprime_y_suffix\u0026#34;] = \u0026#34;y_re\u0026#34; params[\u0026#34;Hprime_z_prefix\u0026#34;] = rt + \u0026#34;/res/0_Hprime_\u0026#34; params[\u0026#34;Hprime_z_suffix\u0026#34;] = \u0026#34;z_re\u0026#34; params[\u0026#34;energy_units\u0026#34;] = \u0026#34;Ry\u0026#34; # This specifies the units of the Hamiltonian matrix elements as they # are written in Ham_ files. Possible values: \u0026#34;Ry\u0026#34;, \u0026#34;eV\u0026#34; # Set up other simulation parameters: # Files and directories (apart from the Ham_ and Hprime_) params[\u0026#34;scratch_dir\u0026#34;] = os.getcwd()+\u0026#34;/out\u0026#34; # Hey! : you need to create this folder in the current directory # This is were all (may be too many) output files will be written params[\u0026#34;read_couplings\u0026#34;] = \u0026#34;batch\u0026#34; # How to read all input (Ham_ and Hprime_) files. Possible values: # \u0026#34;batch\u0026#34;, \u0026#34;online\u0026#34; # Simulation type params[\u0026#34;runtype\u0026#34;] = \u0026#34;namd\u0026#34; # Type of calculation to perform. Possible values: # \u0026#34;namd\u0026#34; - to do NA-MD calculations, \u0026#34;no-namd\u0026#34;(or any other) - to # perform only pre-processing steps - this will create the files with # the energies of basis states and will output some useful information, # it may be particularly helpful for preparing your input params[\u0026#34;decoherence\u0026#34;] = 1 # Do you want to include decoherence via DISH? Possible values: # 0 - no, 1 - yes params[\u0026#34;is_field\u0026#34;] = 0 # Do you want to include laser excitation via explicit light-matter # interaction Hamiltonian? Possible values: 0 - no, 1 - yes # Integrator parameters params[\u0026#34;elec_dt\u0026#34;] = 1.0 # Electronic integration time step, fs params[\u0026#34;nucl_dt\u0026#34;] = 1.0 # Nuclear integration time step, fs (this parameter comes from # you x.md.in file) params[\u0026#34;integrator\u0026#34;] = 0 # Integrator to solve TD-SE. Possible values: 0, 10,11, 2 # NA-MD trajectory and SH control params[\u0026#34;namdtime\u0026#34;] = 2000 # Trajectory time, fs 计算步数，需要修改 params[\u0026#34;num_sh_traj\u0026#34;] = 300 # Number of stochastic realizations for each initial condition params[\u0026#34;boltz_flag\u0026#34;] = 1 # Boltzmann flag (set to 1 anyways) params[\u0026#34;Temp\u0026#34;] = 300.0 # Temperature of the system params[\u0026#34;alp_bet\u0026#34;] = 0 # How to treat spin. Possible values: 0 - alpha and beta spins are not # coupled to each other, 1 - don\u0026#39;t care about spins, only orbitals matter params[\u0026#34;debug_flag\u0026#34;] = 0 # If you want extra output. Possible values: 0, 1, 2, ... # as the number increases the amount of the output increases too # Be carefull - it may result in a huge output! print(\u0026#39;Parameters of the field (if it is included)\u0026#39;) # Parameters of the field (if it is included) params[\u0026#34;field_dir\u0026#34;] = \u0026#34;xyz\u0026#34; # Direction of the field. Possible values: \u0026#34;x\u0026#34;,\u0026#34;y\u0026#34;,\u0026#34;z\u0026#34;,\u0026#34;xy\u0026#34;,\u0026#34;xz\u0026#34;,\u0026#34;yz\u0026#34;,\u0026#34;xyz\u0026#34; params[\u0026#34;field_protocol\u0026#34;] = 1 # Envelope function. Possible values: 1 - step function, 2 - saw-tooth params[\u0026#34;field_Tm\u0026#34;] = 25.0 # Middle of the time interval during which the field is active params[\u0026#34;field_T\u0026#34;] = 25.0 # The period (duration) of the field pulse params[\u0026#34;field_freq\u0026#34;] = 3.0 # The frequency of the field radiation = energy of the photons params[\u0026#34;field_freq_units\u0026#34;] = \u0026#34;eV\u0026#34; # Units of the above quantity. Possible values: \u0026#34;eV\u0026#34;, \u0026#34;nm\u0026#34;,\u0026#34;1/fs\u0026#34;,\u0026#34;rad/fs\u0026#34; params[\u0026#34;field_fluence\u0026#34;] = 1.0 # Defines the light radiation intensity (fluence), mJ/cm^2 print(\u0026#39;Params Done!\u0026#39;) # Define states: # Example of indexing convention with Nmin = 5, HOMO = 5, Nmax = 8 # the orbitals indices are consistent with QE (e.g. PP or DOS) indexing, which starts from 1 # [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] - all computed orbitals # [ 1, 2, 3, 4, 5, 6] - occupied orbitals # [ 7, 8, 9, 10, 11] - unoccupied orbitals # [5, 6, 7, 8] - active space print(\u0026#39;Set active space and the basis states\u0026#39;) # Set active space and the basis states params[\u0026#34;active_space\u0026#34;] = [4,5,6,7] params[\u0026#34;states\u0026#34;] = [] params[\u0026#34;states\u0026#34;].append([\u0026#34;GS\u0026#34;,[4,-4,5,-5],0.00]) # ground state params[\u0026#34;states\u0026#34;].append([\u0026#34;S1\u0026#34;,[4,-4,5,-6],0.00]) # excited state -5 -\u0026gt; -6 print(\u0026#39;Initial conditions\u0026#39;) # Initial conditions nmicrost = len(params[\u0026#34;states\u0026#34;]) ic = [] i = 0 while i\u0026lt;1000: j = 0 while j\u0026lt;nmicrost: ic.append([i,j]) j = j + 1 i = i + 10 params[\u0026#34;iconds\u0026#34;] = ic ############################################################################################# # Execution section: Here we actually start the NA-MD calculations and the analysis ############################################################################################# print(\u0026#39;Run calculations\u0026#39;) ############ Run calculations ###################### print params # print out all simulation parameters first print(\u0026#39;\\t\u0026#39;) print(\u0026#39;print params\u0026#39;) print(\u0026#39;\\t\u0026#39;) pyxaid_core.info().version() print(\u0026#39;\\t\u0026#39;) print(\u0026#39;pyxaid_core.info done\u0026#39;) print(\u0026#39;\\t\u0026#39;) pyxaid_core.namd(params) print(\u0026#39;\\t\u0026#39;) print(\u0026#39;pyxaid_core.namd done\u0026#39;) print(\u0026#39;\\t\u0026#39;) print(\u0026#39;\u0026#39;) print(\u0026#39;Below we will be using the average.py module\u0026#39;) print(\u0026#39;\u0026#39;) ########### Below we will be using the average.py module ######## # Note: If you want to re-run averaging calculations - just comment out the line # calling namd() functions (or may be some other unnecessary calculations) Nstates = len(params[\u0026#34;states\u0026#34;]) # Total number of basis states inp_dir = os.getcwd()+\u0026#34;/out\u0026#34; # this is the directory containing the input for this stage # it is the directory where pyxaid_core.namd() has written all # it output (raw output) opt = 12 # Defines the type of the averaging we want to do. Possible values: # 1 - average over intial conditions, independnetly for each state # 2 - sum the averages for groups of states (calculations with opt=1 must # already be done). One can do this for different groups of states without # recomputing initial-conditions averages - they stay the same # 12 - do the steps 1 and 2 one after another print(\u0026#39;\u0026#39;) print(\u0026#39;Define the groups of states for which we want to know the total population as a function of time\u0026#39;) print(\u0026#39;\u0026#39;) # Define the groups of states for which we want to know the total population as a function of time MS = [] for i in range(0,Nstates): MS.append([i]) # In our case - each group of states (macrostate) contains only a single basis configuration # (microstate) res_dir = os.getcwd()+\u0026#34;/macro\u0026#34; # Hey! : you need to create this folder in the current directory # This is where the averaged results will be written print(\u0026#39;\u0026#39;) print(\u0026#39; Finally, run the averaging\u0026#39;) print(\u0026#39;\u0026#39;) # Finally, run the averaging average.average(params[\u0026#34;namdtime\u0026#34;],Nstates,params[\u0026#34;iconds\u0026#34;],opt,MS,inp_dir,res_dir) 结果分析： 获取Population：\n进入macro文件夹，数据位于sh_pop_ex1中，x轴为第二列，y轴为第6列。\n获取Dephasing和Spectral_density：\n先在step3建一个FFT文件夹，然后进去out文件夹，cp icond0pair0_1Dephasing_function.txt(1列x轴数据，3列为y轴数据)和icond0pair0_1Spectral_density.txt（4列为x轴数据，8列为y轴数据）文件到FFT文件夹\n绘制图 源数据导入到origin中\nPop： 载流子寿命：\n圈起来的那两列为所需数据\npop.dat\n绘制后应该是从1下降，斜率为K, -1/K为寿命（单位为 fs） pop.img\n要得到K,需要使用origin拟合斜率，y轴截距设置为1。\nfit\nDephasing: 退相干：\n将icond0pair0_1Dephasing_function.txt的第一和第三列作为x和y导入origin，绘制图。\ndephasing.img\n认为下降到0.6就是Dephasing time（单位 fs）\nSpectral_density: 振动谱：\n将icond0pair0_1Spectral_density.txt的第4列作为为x轴，第8列作为y轴）导入至origin，设置好x轴范围\n附录 pyxaid2/PYXAID2 at master · Quantum-Dynamics-Hub/pyxaid2 PYXAID Prof. Jin Zhao\u0026rsquo;s research group Teaching | Prof. Jin Zhao\u0026rsquo;s research group(Solid State Phyics Course) Jupyter Notebook Viewer（Hefei - NAMD） Qijing Zheng ","date":"2024-12-10T01:20:09+08:00","image":"https://quantum-dynamics-hub.github.io/pyxaid/pyxaid_logo.png","permalink":"https://allergicrosen.fun/p/namd/","title":"NAC计算"},{"content":"这是一个vasp.5.4.4的编译教程（以广州超算为例）\n准备好vasp.5.4.4安装包 自行下载，或者邮件给我留言 点击发送电子邮件至liaojinbo1999@163.com ，vasp为商业软件，请确保有授权！\n好了，准备好压缩包vasp.5.4.4.tar.gz，解压，进入解压后的目录。\ntar -zxvf vasp.5.4.4.tar.gz cd vasp.5.4.4/ ls发现有以下文件和目录\n$ ls arch bin build makefile README src arch/：该目录通常包含特定于硬件架构的配置文件，例如针对不同操作系统和硬件架构的Makefile模板。你可以在这里选择或创建适合你系统的配置文件。\nbin/：该目录通常为空，或者包含最终编译的VASP可执行文件。在编译完成后，VASP的可执行文件会放在这个目录下。\nbuild/：此目录通常包含用于编译过程的临时文件。编译时会生成对象文件和中间文件，最终会被链接到 bin/ 目录中的可执行文件(std、gam、ncl)。\nmakefile：这个文件是VASP的主Makefile，包含编译VASP所需的各种参数设置和规则。你需要根据你系统的环境编辑这个文件以适应你的编译器和库。\nREADME：该文件通常包含VASP的安装说明、编译和运行的基本指导。在安装之前，建议阅读该文件。\nsrc/：这个目录包含VASP的源代码。编译时，所有源代码文件将被编译成目标文件，然后链接成最终的VASP可执行文件。\n配置环境 查看HPC已有的编译器 命令行输入module av\n$ module av --------------------------------------------------- /APP/u22/x86/modulepath/Compilers --------------------------------------------------- gcc/9.5.0 mpi/mpich/4.1.2-gcc-11.4.0-ch4 mpi/mpich/4.1.2-icx-oneapi2024.2-ch4-dbg intel/oneapi2023.2_impi mpi/mpich/4.1.2-gcc-11.4.0-ch4-dbg mpi/mpich/4.3.2-icc-oneapi2023.2-ch4 intel/oneapi2023.2_noimpi mpi/mpich/4.1.2-icc-oneapi2023.2-ch3-shared mpi/openmpi/4.1.1-icc-oneapi2023.2-ch4 intel/oneapi2024.2_impi mpi/mpich/4.1.2-icc-oneapi2023.2-ch4 mpi/openmpi/4.1.6-icc-oneapi2023.2-ch4 intel/oneapi2024.2_noimpi mpi/mpich/4.1.2-icc-oneapi2023.2-ch4-dbg mpi/openmpi/5.0.0-gcc-9.5.0-ch4 mpi/mpich/3.4.3-gcc-9.5.0-ch4 mpi/mpich/4.1.2-icx-oneapi2023.2-ch4 mpi/openmpi/5.0.0-gcc-11.4.0-ch4 mpi/mpich/4.1.2-gcc-9.5.0-ch4 mpi/mpich/4.1.2-icx-oneapi2023.2-ch4-dbg mpi/openmpi/5.0.0-icc-oneapi2023.2-ch4 mpi/mpich/4.1.2-gcc-9.5.0-ch4_openfoam mpi/mpich/4.1.2-icx-oneapi2023.2-ch4_openfoam mpi/openmpi/5.0.0-icx-oneapi2023.2-ch4 mpi/mpich/4.1.2-gcc-11.4.0-ch3 mpi/mpich/4.1.2-icx-oneapi2024.2-ch4 我需要使用Intel编译器和MPI编译环境，所以我选择加载这两个\nmodule purge module load intel/oneapi2023.2_impi module load mpi/mpich/4.1.2-gcc-11.4.0-ch4 module list 为了确保不与其它模块冲突，所以使用module purge最开始先卸载所有模块，为了确认是否成功加载模块，使用了module list命令 检查已加载的模块。\n进入arch目录下，选择所需的makefile文件\n$cd arch/ $ ls makefile.include.linux_gnu makefile.include.linux_intel makefile.include.linux_intel_serial makefile.include.linux_pgi 因为我使用intel的编译器，所以我将makefile.include.linux_intel复制到上一级目录，命名为makefile.include\n$ cp makefile.include.linux_intel ../makefile.include 打开上一级目录中自己刚复制过来的makefile.include发现其内容如下：\n# Precompiler options CPP_OPTIONS= -DHOST=\\\u0026#34;LinuxIFC\\\u0026#34;\\ -DMPI -DMPI_BLOCK=8000 \\ -Duse_collective \\ -DscaLAPACK \\ -DCACHE_SIZE=4000 \\ -Davoidalloc \\ -Duse_bse_te \\ -Dtbdyn \\ -Duse_shmem CPP = fpp -f_com=no -free -w0 $*$(FUFFIX) $*$(SUFFIX) $(CPP_OPTIONS) FC = mpiifort FCL = mpiifort -mkl=sequential -lstdc++ FREE = -free -names lowercase FFLAGS = -assume byterecl -w OFLAG = -O2 OFLAG_IN = $(OFLAG) DEBUG = -O0 MKL_PATH = $(MKLROOT)/lib/intel64 BLAS = LAPACK = BLACS = -lmkl_blacs_intelmpi_lp64 SCALAPACK = $(MKL_PATH)/libmkl_scalapack_lp64.a $(BLACS) OBJECTS = fftmpiw.o fftmpi_map.o fft3dlib.o fftw3d.o INCS =-I$(MKLROOT)/include/fftw ................ 这个文件是编译所需的环境，确保环境正常\n确保编译环境已加载（也就是前面提到的） module purge module load intel/oneapi2023.2_impi module load mpi/mpich/4.1.2-gcc-11.4.0-ch4 module list 不放心可以再次执行下，或者module list查看下\n开始编译 回到vasp主目录下，开始编译\n因为我需要std、gam、和ncl，所以我直接输入make all，如果没有问题那就会开始编译，等待即可（需要几十分钟）。\n编译完成进入./bin目录下,发现多了这三个执行文件，那么表示以及成功了。\n$ cd bin/;ls vasp_gam vasp_ncl vasp_std 设置环境变量 两种方法\n将vasp_gam vasp_ncl vasp_std所在路径添加到~/.bashrc（推荐使用） vi ~/.bashrc export PATH=/your path/vasp.5.4.4/bin/:$PATH source ~/.bashrc 将其写入脚本\n后续会讲到 测试 编译完后测试下是否能正常运行，准备好测试文件\n我这里准备了5个文件，分别为INCAR、POSCAR、POTCAR、KPOINTS、vasp-sbatch.sh\n脚本编写 在测试前，可能很多人并不知道如何编写一个合适的任务提交脚本，这里我简单介绍下脚本的编写规则\n查看官方手册 最简单的就是查看官方的手册，以广州超算来说，打开HPC1系统用户手册可以找到脚本的编写规则\n目前 HPC1 系统部署的资源管理系统包括多种作业提交方式，包括批处理作业提交方式 yhbatch 和交互作业提交方式 yhrun。作业终止方式为 yhcancel 命令，需要获取作业的 jobid，可以通过 yhq 命令查看获得。\n如果没有交互需求，请使用 yhbatch 提交任务。yhbatch 提交的作业终端关闭 时不会受到影响，登陆结点 down 机时也不会受到影响，强烈推荐使用 yhbatch 提 交任务。\nyhbatch 运行的主要格式如下：\nyhbatch [options] program yhbatch 包括多个选项，用户最常使用的选项如下：\n-n, --ntasks=ntasks 指定要运行的进程数。请求 yhrun 分配/加载 ntasks 个进程。省缺的情况是每 个 CPU 核运行一个进程，但是-c 参数将改变此省缺值。\n-N, --nodes=minnodes[-maxnodes] 请求为此作业至少分配 minnodes 个结点。调度器可能决定在多于 minnodes 个结点上启动作业。可以通过指定 maxnodes 限制最多分配的结点数（如“\u0026ndash; nodes=2-4”）。最少和最多结点数可以相同以便指定确切的结点数（如“\u0026ndash; nodes=2-2”将请求两个并且仅仅两个结点）。如果没有指定-N，省缺的行为是分 配足够的结点以满足-n 选项的要求。\n-p, --partition=partition 从分区 partition 请求资源。如未指定，则省缺为默认分区。\n-t, --time=minutes 设置作业的运行时间限制为 minutes 分钟。省缺值为分区的时间限制值。当到 达时间限制时，作业的进程将被发送 SIGTERM 以及 SIGKILL 信号终止执行。完 整格式为\u0026ndash;time=days-hours:minutes:seconds，建议包机时用户使用该选项。\n-D, --chdir=path\n加载的作业进程在执行前将工作目录改变到 path 。省缺情况下作业 yhrun 进 程的当前工作目录。\n-l, --label 在标准输出/标准错误的每行之前添加任务号。通常，远程任务的标准输出和 标准错误通过行缓冲直接传递到 yhrun 的标准输出和标准错误。\u0026ndash;label 选项将在 每行输出前面添加远程任务的 ID。\n-J, --job-name=jobname 指定作业的名字。省缺值是可执行程序的名字 program 。\n-W, --wait=seconds 指定在第一个任务退出后，到终止所有剩余任务之前的等待时间。0 表示无限 等待（60 秒后将发出一个警告）。省缺值可由系统配置文件中的参数设置。此选 项用于确保作业在一个或多个任务提前退出时能够及时终止。\n-w, --nodelist=nodelist|filename 请求指定列表中的结点。分配给作业的将至少包含这些结点。nodelist 可以是 逗号分割的结点列表或范围表达式（如 cn[1-5,7,12]）。如果包含“/”字符，则 nodelist 将会被当作是一个文件名，其中包含了所请求的结点列表。\n具体不多赘述了，有需要的可以向我要官方文档[ 点击发送电子邮件 ]\n编写脚本 以手册为例： sub.sh 如下：\n#!/bin/bash VASP_BIN=/your path/vasp.5.4.4/bin/vasp_std yhrun -n 28 -p TH_HPC1 $VASP_BIN 前面提到yhrun是交互提交作业,虽然可以提交任务，但是要保证窗口一直挂着，且不能断链，这显然是很不方便的，所以还需要yhbatch提交脚本。\n将脚本命名为run.sh:\n#!/bin/bash module purge module load intel/oneapi2023.2_impi module load mpi/mpich/4.1.2-gcc-11.4.0-ch4 module list export PATH=/your path/vasp.5.4.4/bin/:$PATH yhbatch -n 28 -p TH_HPC1 -J example1 ./sub.sh 自己写sbatch任务脚本 虽然以上脚本可以满足要求了，但是我还是觉得很麻烦，为什么我需要写两个脚本，我直接写一个多好，所以这是另一个方法，使用的是sbatch\n具体用法参照官方手册slurm官方手册 这是我自己的脚本：\n#!/bin/bash #SBATCH -J ljb ## Job Name #SBATCH -o out.%j ## standard output #SBATCH -e err.%j ## standard error #SBATCH -p mars ## Partition #SBATCH -N 1 ## Number of nodes #SBATCH --ntasks-per-node=64 ## Each node has n tasks #SBATCH -t 07-23:57:25 ## time for your job: 2 d，23 h ，57 min and 23 s module purge module load intel/oneapi2023.2 module load mpi/mpich/4.1.2-gcc-11.4.0-ch4 export PATH=/your path/vasp.5.4.4/bin/vasp_ncl:$PATH module list ulimit -s unlimited VASP_BIN=/your path/vasp.5.4.4/bin/vasp_std yhrun $VASP_BIN 运行测试 准备好vasp所需文件：\nls INCAR KPOINTS POSCAR POTCAR vasp-sbatch.sh sbatch vasp-sbatch.sh Submitted batch job 133974 squeue查看节点状态，显示R\nJOBID PARTITION NAME USER ST TIME NODES NODELIST(REASON) 133974 mars ljb caep_lts R 1:28 1 cnode5131 显示已提交成功。\n检查OUTCAR或者out.133974（根据实际名字查看）文件是否正常运行\n$ tail out.133974 POSCAR found type information on POSCAR Pb I C N H POSCAR found : 5 types and 92 ions scaLAPACK will be used LDA part: xc-table for Pade appr. of Perdew POSCAR, INCAR and KPOINTS ok, starting setup FFT: planning ... WAVECAR not read entering main loop N E dE d eps ncg rms rms(c) DAV: 1 0.129655355373E+04 0.12966E+04 -0.13885E+05 17024 0.108E+03 顺利运行且无报错，完毕。\n","date":"2024-11-27T18:01:14+08:00","image":"https://allergicrosen.fun/p/vasp_compile/vasp_hu_fbc6db46ef87255b.webp","permalink":"https://allergicrosen.fun/p/vasp_compile/","title":"广州超算编译安装Vasp.5.4.4"},{"content":"Hugo在个人网站增加评论区的功能 Step1 :打开hugo主目录（前提已经部署好） Step2 :打开hugo.yaml配置文件，移到comments: comments: enabled: true provider: utterances disqusjs: shortname: apiUrl: apiKey: admin: adminLabel: utterances: repo: allergicrosen/myblog issueTerm: pathname label: beaudar: repo: issueTerm: pathname label: theme: remark42: host: site: locale: vssue: platform: owner: repo: clientId: clientSecret: autoCreateIssue: false 确保\nenabled: true provider: utterances 其它的不用可以删掉，保留\nutterances: repo: GitHub名字/静态网页仓库名字（一定注意仓库名字后面什么都不要加） issueTerm: pathname Step3 :为你所需要的仓库配置utterances 打开链接https://github.com/apps/utterances 登录验证，按照提示操作，选择所需仓库进行安装\n完毕后检查是否安装：所需仓库-\u0026gt;Settings-\u0026gt;Integrations-\u0026gt;Github Apps里可以看到utterances。\nStep4 :重新生成public(hugo.exe在主目录) ./hugo.exe server-D 此时应该已经成功了。\n","date":"2024-10-17T00:00:00Z","image":"https://allergicrosen.fun/p/hugo/cover_hu_ce5843295186a595.png","permalink":"https://allergicrosen.fun/p/hugo/","title":"hugo增加utterances功能"},{"content":"\n所需东西有： 微信开发者工具 本项目源码 有一定的HTML+CSS+Javascript的经验（小程序与网页设计非常类似） 安装node.js 申请注册微信公众平台：微信公众平台 好了，正式开始 获取源码 这位大佬做的源码UxxHans/Rainbow-Cats-Personal-WeChat-MiniProgram 其实按照他的教程基本上就可以自己部署好了，不过我自己修改增加了一些功能\n这是原本的主页及其它页面见以上链接\n修改的主要是主页，增加了一个轮转的图册，优化了样式，增加开盲盒功能等等。。。\n好的废话不多说，继续。\n微信开发者工具导入源码 打开微信开发者工具，导入解压目录\nd----- 2024/10/15 17:26 cloudfunctions d----- 2024/10/14 16:02 miniprogram d----- 2024/10/14 17:20 node_modules d----- 2024/10/14 16:02 Pics -a---- 2023/8/15 21:15 551 .eslintrc.js -a---- 2023/8/15 21:15 13 .gitignore -a---- 2023/8/15 21:15 1069 LICENSE -a---- 2024/10/14 17:20 80249 package-lock.json -a---- 2024/10/14 17:20 58 package.json -a---- 2024/10/15 11:00 1899 project.config.json -a---- 2024/10/14 16:09 359 project.private.config.json -a---- 2023/8/15 21:15 5891 README.md 注意应当是导入这个目录\nd----- 2024/10/14 16:02 miniprogram 因为作者写的云函数，所以需要用到云开发工具，点击左上角的云开发按钮\n云开发是收费的，不过第一个月可以白嫖，可以开了后把自动续费关掉\n这个目录就是存放所有云函数的文件夹，\nd----- 2024/10/15 17:26 cloudfunctions 注意到这里需要运行cloudfunctions/Install-WX-Server-SDK.bat，然后一个一个将函数上传。（请注意其它所需操作我并未列出，因为UxxHan大佬源码主页有明确过程）\n其实到这一步基本全部完成了，按作者要求填写好自己和对方_openid就行了\n这里主要讲下订阅微信通知需要怎么做\n订阅通知 来到微信小程序平台微信小程序平台 点击基础功能———订阅消息，去挑选一个适合自己的模板\n复制模板ID到miniprogram/pages/MainPage/index.js和miniprogram/pages/MissionAdd/index.js里把模板号换成自己想要的模板号 记得在cloudfunctions/information/index.js里把UserA和UserB的openid值替换\n样式和内容修改 如果你并不喜欢这些页面内容，修改index.wxml,修改样式，修改index.wxss，增加新功能等等，修改index.js\n导航栏名字和图标修改只需要修改miniprogram/app.json文件\n代码提交 右上角上传按钮就行了，记得去微信小程序平台提交审核并发布。\n相关链接\nHTML菜鸟教程 Javascript菜鸟教程 CSS菜鸟教程 ","date":"2024-10-17T00:00:00Z","image":"https://allergicrosen.fun/p/%E5%8A%A8%E6%89%8B%E5%81%9A%E4%B8%80%E4%B8%AA%E5%92%8C%E5%A5%B3%E6%9C%8B%E5%8F%8B%E4%BA%92%E5%8A%A8%E7%9A%84%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/WeChatminiprogram_hu_ddbfd2eda7b2425.webp","permalink":"https://allergicrosen.fun/p/%E5%8A%A8%E6%89%8B%E5%81%9A%E4%B8%80%E4%B8%AA%E5%92%8C%E5%A5%B3%E6%9C%8B%E5%8F%8B%E4%BA%92%E5%8A%A8%E7%9A%84%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/","title":"动手做一个和女朋友互动的微信小程序"},{"content":"本人咸鱼，有空就更，没空就在划水 主要记录一些想法，日常，还有知识分享。\n个人喜欢的一首歌 三月走过 柳絮散落\n恋人们匆匆\n我的爱情 闻风不动\n翻阅昨日 仍有温度\n蒙尘的心事\n恍恍惚惚 已经隔世\n遗憾无法说 惊觉心一缩\n紧紧握着 青花信物\n信守着承诺\n离别总在 失意中度过\n记忆油膏 反复涂抹\n无法愈合的伤口\n你的回头 划伤了沉默\n那夜重逢 停止漂泊\n你曾回来过\n相濡相忘 都是疼痛\n只因昨日 善良固执\n委屈着彼此\n打碎信物 取消来世\n遗憾无法说 惊觉心一缩\n紧紧握着 青花信物\n信守着承诺\n离别总在 失意中度过\n记忆油膏 反复涂抹\n无法愈合的伤口\n你的回头 划伤了沉默\n紧紧握着 青花信物\n雕刻着寂寞\n就好像我 无主的魂魄\n纠缠过往 无端神伤\n摔碎谁也带不走\n你我一场 唤不醒的梦\n紧紧握着 青花信物\n信守着承诺\n离别总在 失意中度过\n记忆油膏 反复涂抹\n无法愈合的伤口\n你的回头 划伤了沉默\n紧紧握着 青花信物\n雕刻着寂寞\n就好像我 无主的魂魄\n纠缠过往 无端神伤\n摔碎谁也带不走\n你我一场 唤不醒的梦\n青花 - 周传雄 ","date":"2024-09-09T00:00:00Z","image":"https://allergicrosen.fun/p/%E9%9A%8F%E7%AC%94/wallhaven-x6r1wd_hu_e3b97114ff8f1ced.jpg","permalink":"https://allergicrosen.fun/p/%E9%9A%8F%E7%AC%94/","title":"博客网站"}]